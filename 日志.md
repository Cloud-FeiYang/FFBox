# 开发模式

vite server 启动后端（如端口占用，退出返回错误码），后端安静地等待接入。
vite server 启动前端，dev 模式下前端启动后端的逻辑改为手动点击按钮输入 pid。相关操作由 main 来控制，通过 ipc 发送给 renderer 结果。

# 生产模式

1. webpack 打包后端
1. vite 打包 electron main
1. vite 打包 electron rendrerer
1. vite 打包 electron preload
2. electron builder 产出可执行包，复制后端 exe 到目录
3. 手动打 Windows 安装包

# 开发日志

## 2022-12-11

确定了项目模块与打包器对应的大致逻辑。

已实现使用 webpack 对 backend 的 Hello world 进行打包，@common 也可打包进程序，并使用 pkg 生成 exe。后期需引入 koa 一系列东西去测试能否正常打包。

正在尝试调试 backend。目前已实现使用 webpack 打包（带 source-map）完成后再使用 vscode 对生成文件进行调试。仍需探索使用 vite devServer 的方式而不是 webpack 输出文件。如果确实不行，这样分两步也没太大问题，不过最好有个脚本可以合并这个操作。

[这里](https://stackoverflow.com/questions/66147328/is-there-a-way-to-debug-code-in-vscode-initiated-with-vite)有人说可以用 vscode 调试 vite 打包的项目。

## 2022-12-12

vite devServer 无用了，因为找不到一种方法，可以让 vscode 启动调试任务时，让 vite 启动一个 devServer 进行 HMR 编译。vite CLI 可以启动 devServer 服务，但是它不进行编译。vite Node API 可以编译，但代码逻辑只是让它感知到代码变化后重新 build 到 app/backend 里去，编译输出的文件跟 server 似乎没什么关系。

所以干脆就做成在 vscode 里启动调试之后，先用 vite CLI 进行 build，等完成之后用传统方法启动一个 vscode 调试任务（启动 js，map 到 ts）。同样的，webpack 也能实现这个功能。于是就做了 vite 和 webpack 两套方案。

下一步应该是要先打通引入了 koa 之后的 backend 输出到 exe（不急着写脚本）。然后写使用 vite 进行 electron Hello world 开发的脚本。这一步理论上不太难，因为已经有别的框架打了模板。
如果确实要做 HMR 的话，vscode 的文档里有指南。这里放一个 vue 的[链接](https://github.com/microsoft/vscode-recipes/tree/main/vuejs-cli)。

## 2022-12-13

引入了部分 koa 之后，vite 直接成功，webpack 下 formidable 会出运行时错误，需要根据[链接](https://github.com/node-formidable/formidable/issues/337)手动配置 hexoid 路径才成功，原因未知。

## 2022-12-16

打开所有了后端代码之后的运行都成功了。vite 依然是一次成功，webpack 则卡在了 ws 库上。依然没去探寻默认值下打包失败的原因，不过[这个地方](https://github.com/websockets/ws/issues/1538)基本包含了全部的解决方案。可以用 resolve 强行把入口指向 node_module 下的文件，也可以换个导入方法（改代码）。

## 2022-12-17

增加了用于 renderer、preload、main 的 vite 配置，dev-frontend 和 build 基本上都是一次成功。只是稍微研究了下导入路径。已经实现引入 vue3 Hello world 之后使用 dev 模式启动。

目前 vite:renderer 这步只差 index.html 的编译就能导进 electron-builder 了。

下一步就应该去设计 interface 和主控逻辑了。目前还没想好从哪开始做起。目前可知的是，按之前想过的内容，应该要构思一下如何做两边的连通。比如说生产环境下直接 spawn，开发环境下……不知道……

## 2022-12-18

连通方式大致是：生产环境下直接 spawn，开发环境下启动一个 node --inspect 或者 --inspect-brk。这样，在 FFBox 启动后将自动启动一个 backend，此时只需要在 vscode 使用 attach 模式进入调试就可以了。launch.json 已经增加了 attach 模式，剩下的就是后续在 main 里 spawn 一个 node 了。

index.html 这步也已完成。把 config 中的 lib 去掉就可以了。导进 electron-builder 打包之后能直接启动。

因为该版本需要考虑 preload，所以也进行了 preload 的尝试。目前也已成功将 preload 里的 electron API 引入 renderer 里使用。不能直接把整个 API 对象导出来，需要细分到里面的方法，因为导出整个 API 的话里面就包含了一些不是 JavaScript 上下文的东西。

renderer 方面，引入了 jsx，还没尝试能不能用。

## 2022-12-19

开始了界面的设计，正在设计整体框架。less 引入直接成功，零配置。

## 2022-12-20

volar 扩展似乎安装成功了。之前用的一直是 v0.36，即使重装插件也是 v0.36，直到关闭所有页面升级 vscode 后才装上了 v1。此前 .vue 文件是没有代码提示的。

## 2022-12-23

加入了 256px 无边距透明的 logo，适配了无边框样式的一些细节。

## 2022-12-24

研究了一下 box-shadow 的渐变机制，发现 W3C 并没有对使用何种算法渲染阴影有规定。因此我测试出来，chromium 的阴影并不线性，只能知道阴影最远向外扩散到多少像素，至于向内，阴影浓度很快就接近 100%，但直到超过了指定像素一小段距离才真正达到 100%。

做这个测试是因为今天给 FFBox 引入了无边框，正在给 FFBox 标题栏增加 tabs，ActionBar 上的那一道亮光导致了 tabs 跟 ActionBar 的过渡并不柔和。

另外，做了一下三大金刚键的一部分，然后就去捣鼓怎样引入 svg 了。默认的引入方式是 img 标签，但这样无法控制颜色，因此还是需要一个 loader。npm 上搜到的第一个便是，虽然看起来挺方便易用，但是我马上发现了一个 [bug](https://github.com/jpkleemans/vite-svg-loader/issues/86)。vite 对 vue 的社区支持明显是比 react 好很多，之前在做 ttqftech 的 svg 引入时，搜了很久也只能找到一个略有点不优雅的方案。

## 2022-12-28

确定好了初期 menu 要放什么东西进去。同时也实现了三大金刚键的功能。

另外，electron 已经支持了 window overlay，可以把 Windows 三大金刚键做到窗口上，如果调好了的话就可以使用 Win11 的快速分屏小工具了，缺点是不能移动位置。

目前不打算把它做进去，只是用自己的实现。我的主要诉求骑士是拖动标题栏就能实现分屏等的基础效果。实际上，只要把 transparent 关掉就可以了。按目前的 UI 设计来说，也没有一定需要该窗口透明才能实现的东西，因此就这么用了。

## 2022-12-29

继续优化了一下 tab 按钮和三大金刚键的阴影效果。

## 2022-12-30

补充了参数面板的相关设计，包括六个按钮和全局参数的布局关系，仔细调整了面板和按钮的阴影。另外，动作栏也加上了“添加任务”按钮（样式待优化），后期在中间加上搜索框就完整了（4.0 暂时不做提示功能）。

参数盒里的控件是动态渲染出来的，所以稍后再做。下一步需要设计的是任务项的样式。完了之后就该尝试加上 pinia，给界面分文件了。

## 2023-01-23

任务项要长成什么样子，这个其实想了很久。而且任务项本身包含的东西比较多，如果要像 v1.0 那样，把东西先用 HTML hardcode 进去，也不是不行。但这样后期就得再做适配，时间成本上可能不如我先把工程化做好一点，接入实际数据更好。

另外，由于我对我自己目前设计出来的界面并不满意，也对自己每天排满活的行为并不满意，所以停了一段时间。

git 提交的节奏还是做不到瞬间转变，所以要在一次提交里包含比较多的东西。这次由于已经拖了一段时间了，所以干脆就直接先把 pinia 弄了，做一下工程化。

因为技术栈发生了 Vue 2 -> Vue 3，VueX -> Pinia，时序上有些变化。index.ts 里的 setActivePinia 就是变化的体现。在之前的版本里，VueX 是插入到 Vue 里，在组件函数里引用的；而现在引用的位置放到了顶层而不是函数里，这样就需要在 createApp 之前手动设置一下 pinia 实例，而不能 createApp 完了之后再 app.use。

## 2023-02-01

正在尝试给 store 添加东西了。

首先添加的是 servers，为此引入了之前的几个 bridge。在以前的代码里，使用了 remote、process 这种在现代 electron、浏览器中不受支持的 API，因此也对相关的函数做了小幅更改。

另外就是遇到了一个 vite 相关的文件引入问题，已修改配置解决。还剩下的一个问题是 vite 似乎读不到 EventEmitter。

## 2023-02-02

在渲染进程中，因为开启了一些 electron 的隔离功能，所以不能用 node 的 EventEmitter。昨天的问题是这个。引入 events 库就好了。

往 store 中加入了添加服务器和任务的功能，尚未做服务器事件监听，因此服务器中的数据目前传不到前端。得考虑开始做模块化了。

## 2023-02-08

把 MainFrame 中 container 里的东西拆成四大块之后，终于能“清爽”地进行接下来的开发了。
（其实前几块的铺垫都是为了搞 01-23 所说的任务项 TaskItem，想直接把 store 中的数据通给它做渲染）

这次的主要难点在于引入 jsx。首先引入 @vitejs/plugin-vue-jsx 的作用就是给 vite 引入一个 babel 做转换（大致是这么回事），但对功能以外的东西它并不关心。于是我就遇到了两个问题：eslint 和 ts。
对于 eslint，解决方案是增加 parser 和 parserOptions 字段；
对于 TypeScript，解决方案是 jsx 字段值改为 "preserve"。另外，不能使用 React 特有的“className”之类的属性，这个在 vue 文档中就有说到。

另外也大致明白了 jsx 在 vue 中担任怎样的角色。实际上，vue 本身就支持直接用 js 而不是模板语法写组件，其中就包括了 class component 和 function component。jsx 插件只是把其中的 jsx 转换成 h 函数而已。另外，这个插件不仅对 .jsx、.tsx 生效，甚至对 .vue 也生效，也就是可以在 `<script>` 标签中写 jsx 组件给 template 用。

## 2023-02-10

02-02 中写到，目前还没有做后端消息的 handler，所以传不到前端。因此目前在做的就是 serverEventsHandler。

在之前，由于使用 VueX，mutations 要调用另一个 mutation 是不行的，得用 mainVue 这种比较 hack 的方式。现在用 Pinia 之后直接 useStore 就行了。
不过 initializeServer 函数里有个地方需要 as Server。怀疑 Pinia 对它做了点转换，导致这个数据实际上是被深拷贝了一份，但目前不确定是不是这么回事（也有可能只是 ts 做了下转换），因此需要先把前后端通讯打通，验证这个问题。

打通前后端的过程中，因为涉及到具体的运行逻辑了，需要把 nodeBridge 的一些功能也做下适配（包括 preload），目前正在进行中。

## 2023-02-11

接通后端的过程比较顺利，几乎是一接通就能用了，很好。
（而且还能用老 FFBox 起服务器，在目前还没改后端数据结构的情况下，直接就开箱即用了）

然后是关于 nodeBridge 适配的问题。过往的代码中，renderer 还是带了很多跟 electron 或者 node 相关性比较大的代码，比如说直接在渲染进程 spawn 一个进程、用 remote 去 flashFrame 或者 openDevTools 等。为了实现分离，最好的方法是页面要假设不知道下层是 electron，所以这些功能就得都集合到 nodeBridge 里，而 nodeBridge 对接的 preload 也直接改成了 `jsb` 这个名字。

下一步就是 taskItem 的设计了。目前完成了 tasklist 的分离，仍需继续制作。

另外，目前的列表刷新机制好像会导致 vue 出现 internal bug，具体还需继续排查。

## 2023-02-14

今天先写了一下 taskItem 里参数展示的样式，然后为了使用 videoRateControl 这类 computed 值，排查了一下 internal bug 的原因。
猜测是因为我给 v-for 的 key 传了个对象，猜测正确。
于是找了一下以前的解决办法，是另有一个 computed 值，把 id 插入到列表中的每一个项。这个做法，是为了节省一个字段，😂很有“个性”🤔。

另外，如果使用了 computed，console 中出现了 `Invalid VNode type: undefined (undefined)` 的 warning，可能是由于忘记取 .value 所致。Vue 的错误提示在这点上十分不友好。

目前设计了四项信息展示，但此时的列表宽度已经非常高了，导致文件名没什么位置放。尝试使用老版 FFBox 的多行溢出属性，没成功，得后面继续调。

## 2023-02-15

继续调整 taskItem 的样式，加入了左侧图标和右侧操作按钮。
同时参照老版 FFBox 的 taskItem 设计重新实现阴影。当年为了实现个阴影套了几层 div，确实是对视觉效果的要求很高🙈。
比现在调半天还丑不拉几的我艺术感好多了。

## 2023-02-21

继续实现 taskItem 的功能，加入了 dashboardArea 和 cmdArea。Of course 所有按钮都还没做响应，然后根据元素宽度自动开关和伸缩某些字段的功能也还没做，所以现在看起来还是不太顺眼的状态。

途中发现了 CSS :has 选择器，直到去年 8 月才在 chromium 上线。这叫及时雨。

## 2023-02-22

往 store 中加了几个界面类的属性，还没写功能。因为静态界面开发太久了，想看看它交互起来怎么样。
于是着手去改一下 ParaBox 的设计。首先是分了文件，然后要把里面的 sidebar-icon 都换成 svg。
但就卡在了 svg 这一步：

### 样式异常

使用 Ai 直接导出 svg，样式会以内部 CSS 形式被放到 `<defs><style></style></defs>` 里去。而 vite-plugin-svg 将其转换为 vue 组件的时候，由于 vue 不支持在组件中使用 `<style>`，所以样式会被去掉。在 vite-svg-loader 的 issues 中，有两种解决方案：

- [链接](https://github.com/jpkleemans/vite-svg-loader/issues/56#issuecomment-1160290025) 中提到，可以在 svgo 设置中启用 inlineStyles 插件，把样式从 `<style>` 中移动到标签内联。但实际上，阅读文档后发现，vite-plugin-svg 默认就启用了 svgo 的默认设置。而默认设置中就启用了这个插件，但插件有 bug，没把样式应用到全部标签上，只会应用一次。这个 [bug](https://github.com/svg/svgo/issues/1743) 在一个月前才被提出。
- [链接](https://github.com/jpkleemans/vite-svg-loader/pull/92) 处，有人提了一个 PR，把 `<style` 替换为 `<component is="style"`。同样是在一个月前才被提出。

vue 的生态可谓是非常奇怪，发展了很久，但总是会遇到些新鲜热辣的问题，得等社区解决。

不过在上面提到的第一点中，下面的评论有提到，可以给 inlineStyles 设置 `onlyMatchedOnce: false` 解决。你说这是个 bug 呢还是个 feature 呢 = =。

如果排除上述解决方案，从 Ai 本身入手的话，就得在导出时设置样式为内联样式。这样一来会导致文件明显变大，另外要通过修改导出设置来兼容程序，说明这个工程的兼容性不好，所以不这么做。

不清楚把 vue template 换成 jsx 会不会有这个问题，明日再试。

### 颜色应用

在其他比较常见的 svg 中，整个图形是一个路径，使用 `fill="currentColor"`，就可以实现外部使用 CSS 自定义颜色。

而在 Ai 中导出 svg，它是带了一个颜色的。有如下几种解决方案：

- 在 Ai 里清除掉这个颜色。这当然不考虑，因为这样的话在 Ai 里直接就看不到了。
- 对每个使用颜色的地方使用 CSS `!important`。彳亍，只是我不太喜欢。（要是解决了 style 标签被 vue 吞了的问题，就不需要这样做了）
- 修改每个 svg 文件，把 stroke 手动改为 `stroke:currentColor`。麻烦点，可以减少文件体积。

## 2023-02-23

jsx 依然无法解决 style 标签被 vue 吞掉的问题。另外，jsx 若要给一个包在 `{}` 中的组件设置样式等属性，就需要用到 h 函数了，没有 vue template 那么“原生”。所以还是暂时换回 vue SFC。

另外，解决完上述所有问题之后，“输入”和“输出”图标依然是不正常的。这个锅我认为得让 Ai 背。因为这俩图形是使用路径 + 填色做出来的，Ai 导出后对应的填色标签上并没有任何属性，需要手动写一个 `.cls-3{fill:currentColor;}`，给标签加上这个 class 才行。另外，这种图形在 Ai 里也无法设置复合路径。

解决了 svg 的问题后，继续调整 devider 的样式，加上了全局参数的展示器及展开/折叠按钮，给 devider 加上了拖拽调整高度，顺便做了少量读屏器适配。

## 2023-02-26

补充了一些内容，包括 TaskItem 的“预计剩余时间”占位、其 cmd 选项卡的点击响应及样式优化、Parabox devider 的切换。做到这一步，就要考虑引入 Parabox 了。

Parabox 的引入是个大项，因为一下子就要把许多东西引进来，包括子参数盒页面、所使用到的控件、控件里所使用到的 Tooltip。普通控件需要对它做 vue2 选项式 API 到 vue3 组合式 API setup 的转换，Tooltip 则还需要去看如何凭空创建一个 Vue 组件出来。
本打算按照老经验去看一下 Element Plus 是怎么写的，结果 npmmirror 服务器 502 了装不下来，便去 GitHub 直接看代码。发现它的设计似乎比以前复杂了许多，还没时间去弄懂它，只看到了一些最基础需要用到的代码。
然而，引入之后，一方面是遇到了文件引用未找到的问题（暂时通过移动文件解决），另一方面，解决完其余问题之后，Tooltip 依然是不出现的。还得继续去找原因（有可能是漏了某行 context 的代码）。
已经找到了文件引用未找到的问题的原因。vite 配置中 resolve 漏了 tsx 的文件后缀。

## 2023-03-06

上次的问题，Tooltip 不出现的原因是，vnode 的 props 是个只读属性，直接修改是不行的，需要使用 vnode.component.props 进行修改。简单来说，在 DOM 上新增元素挂载 Vue 组件的方法分为三步：1. 使用所需组件创建 VNode。2. 创建 DOM 节点。3. render。
显然是对 Vue3 的原理不太熟悉，还需后期继续学习。

另外，解决问题的过程也没有一帆风顺，其中就遇到了 dev 模式弹不出来窗口的问题和编译失败的问题。dev 模式出不来窗口是个低级问题了，把 debugger 语句留在了 first render 里；编译失败则依然是 vite 的问题，在编译模式下，尽管跟开发模式使用同一份 config，但生产模式下，resolve alias 读不到，需要使用 path.resolve。

还发现了 Vue 2 到 Vue 3 的一处不同：Transition 组件所使用的 CSS 名称发生了变化。变换起始的类名后面增加了“-from”。解决了组件迁移后只有部分动画的问题。

## 2023-03-09

最近一段时间在迁移 Parabox components，目前已经基本上迁移完成了，不过由于还没打通前端到后端的参数传输，所以看不到实现效果对不对。回看日志可知，做这块工作的目的是为了尽快完成软件主要界面的功能。为了继续开发，下一步就需要去写参数传输到后端的这些逻辑了。
