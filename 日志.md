# 开发模式

vite server 启动后端（如端口占用，退出返回错误码），后端安静地等待接入。
vite server 启动前端，dev 模式下前端启动后端的逻辑改为手动点击按钮输入 pid。相关操作由 main 来控制，通过 ipc 发送给 renderer 结果。

# 生产模式

1. webpack 打包后端
1. vite 打包 electron main
1. vite 打包 electron rendrerer
1. vite 打包 electron preload
2. electron builder 产出可执行包，复制后端 exe 到目录
3. 手动打 Windows 安装包

# 开发日志

## 2022-12-11

确定了项目模块与打包器对应的大致逻辑。

已实现使用 webpack 对 backend 的 Hello world 进行打包，@common 也可打包进程序，并使用 pkg 生成 exe。后期需引入 koa 一系列东西去测试能否正常打包。

正在尝试调试 backend。目前已实现使用 webpack 打包（带 source-map）完成后再使用 vscode 对生成文件进行调试。仍需探索使用 vite devServer 的方式而不是 webpack 输出文件。如果确实不行，这样分两步也没太大问题，不过最好有个脚本可以合并这个操作。

[这里](https://stackoverflow.com/questions/66147328/is-there-a-way-to-debug-code-in-vscode-initiated-with-vite)有人说可以用 vscode 调试 vite 打包的项目。

## 2022-12-12

vite devServer 无用了，因为找不到一种方法，可以让 vscode 启动调试任务时，让 vite 启动一个 devServer 进行 HMR 编译。vite CLI 可以启动 devServer 服务，但是它不进行编译。vite Node API 可以编译，但代码逻辑只是让它感知到代码变化后重新 build 到 app/backend 里去，编译输出的文件跟 server 似乎没什么关系。

所以干脆就做成在 vscode 里启动调试之后，先用 vite CLI 进行 build，等完成之后用传统方法启动一个 vscode 调试任务（启动 js，map 到 ts）。同样的，webpack 也能实现这个功能。于是就做了 vite 和 webpack 两套方案。

下一步应该是要先打通引入了 koa 之后的 backend 输出到 exe（不急着写脚本）。然后写使用 vite 进行 electron Hello world 开发的脚本。这一步理论上不太难，因为已经有别的框架打了模板。
如果确实要做 HMR 的话，vscode 的文档里有指南。这里放一个 vue 的[链接](https://github.com/microsoft/vscode-recipes/tree/main/vuejs-cli)。

## 2022-12-13

引入了部分 koa 之后，vite 直接成功，webpack 下 formidable 会出运行时错误，需要根据[链接](https://github.com/node-formidable/formidable/issues/337)手动配置 hexoid 路径才成功，原因未知。

## 2022-12-16

打开所有了后端代码之后的运行都成功了。vite 依然是一次成功，webpack 则卡在了 ws 库上。依然没去探寻默认值下打包失败的原因，不过[这个地方](https://github.com/websockets/ws/issues/1538)基本包含了全部的解决方案。可以用 resolve 强行把入口指向 node_module 下的文件，也可以换个导入方法（改代码）。

## 2022-12-17

增加了用于 renderer、preload、main 的 vite 配置，dev-frontend 和 build 基本上都是一次成功。只是稍微研究了下导入路径。已经实现引入 vue3 Hello world 之后使用 dev 模式启动。

目前 vite:renderer 这步只差 index.html 的编译就能导进 electron-builder 了。

下一步就应该去设计 interface 和主控逻辑了。目前还没想好从哪开始做起。目前可知的是，按之前想过的内容，应该要构思一下如何做两边的连通。比如说生产环境下直接 spawn，开发环境下……不知道……

## 2022-12-18

连通方式大致是：生产环境下直接 spawn，开发环境下启动一个 node --inspect 或者 --inspect-brk。这样，在 FFBox 启动后将自动启动一个 backend，此时只需要在 vscode 使用 attach 模式进入调试就可以了。launch.json 已经增加了 attach 模式，剩下的就是后续在 main 里 spawn 一个 node 了。

index.html 这步也已完成。把 config 中的 lib 去掉就可以了。导进 electron-builder 打包之后能直接启动。

因为该版本需要考虑 preload，所以也进行了 preload 的尝试。目前也已成功将 preload 里的 electron API 引入 renderer 里使用。不能直接把整个 API 对象导出来，需要细分到里面的方法，因为导出整个 API 的话里面就包含了一些不是 JavaScript 上下文的东西。

renderer 方面，引入了 jsx，还没尝试能不能用。

## 2022-12-19

开始了界面的设计，正在设计整体框架。less 引入直接成功，零配置。

## 2022-12-20

volar 扩展似乎安装成功了。之前用的一直是 v0.36，即使重装插件也是 v0.36，直到关闭所有页面升级 vscode 后才装上了 v1。此前 .vue 文件是没有代码提示的。

## 2022-12-23

加入了 256px 无边距透明的 logo，适配了无边框样式的一些细节。

## 2022-12-24

研究了一下 box-shadow 的渐变机制，发现 W3C 并没有对使用何种算法渲染阴影有规定。因此我测试出来，chromium 的阴影并不线性，只能知道阴影最远向外扩散到多少像素，至于向内，阴影浓度很快就接近 100%，但直到超过了指定像素一小段距离才真正达到 100%。

做这个测试是因为今天给 FFBox 引入了无边框，正在给 FFBox 标题栏增加 tabs，ActionBar 上的那一道亮光导致了 tabs 跟 ActionBar 的过渡并不柔和。

另外，做了一下三大金刚键的一部分，然后就去捣鼓怎样引入 svg 了。默认的引入方式是 img 标签，但这样无法控制颜色，因此还是需要一个 loader。npm 上搜到的第一个便是，虽然看起来挺方便易用，但是我马上发现了一个 [bug](https://github.com/jpkleemans/vite-svg-loader/issues/86)。vite 对 vue 的社区支持明显是比 react 好很多，之前在做 ttqftech 的 svg 引入时，搜了很久也只能找到一个略有点不优雅的方案。

## 2022-12-28

确定好了初期 menu 要放什么东西进去。同时也实现了三大金刚键的功能。

另外，electron 已经支持了 window overlay，可以把 Windows 三大金刚键做到窗口上，如果调好了的话就可以使用 Win11 的快速分屏小工具了，缺点是不能移动位置。

目前不打算把它做进去，只是用自己的实现。我的主要诉求骑士是拖动标题栏就能实现分屏等的基础效果。实际上，只要把 transparent 关掉就可以了。按目前的 UI 设计来说，也没有一定需要该窗口透明才能实现的东西，因此就这么用了。

## 2022-12-29

继续优化了一下 tab 按钮和三大金刚键的阴影效果。

## 2022-12-30

补充了参数面板的相关设计，包括六个按钮和全局参数的布局关系，仔细调整了面板和按钮的阴影。另外，动作栏也加上了“添加任务”按钮（样式待优化），后期在中间加上搜索框就完整了（4.0 暂时不做提示功能）。

参数盒里的控件是动态渲染出来的，所以稍后再做。下一步需要设计的是任务项的样式。完了之后就该尝试加上 pinia，给界面分文件了。

## 2023-01-23

任务项要长成什么样子，这个其实想了很久。而且任务项本身包含的东西比较多，如果要像 v1.0 那样，把东西先用 HTML hardcode 进去，也不是不行。但这样后期就得再做适配，时间成本上可能不如我先把工程化做好一点，接入实际数据更好。

另外，由于我对我自己目前设计出来的界面并不满意，也对自己每天排满活的行为并不满意，所以停了一段时间。

git 提交的节奏还是做不到瞬间转变，所以要在一次提交里包含比较多的东西。这次由于已经拖了一段时间了，所以干脆就直接先把 pinia 弄了，做一下工程化。

因为技术栈发生了 Vue 2 -> Vue 3，VueX -> Pinia，时序上有些变化。index.ts 里的 setActivePinia 就是变化的体现。在之前的版本里，VueX 是插入到 Vue 里，在组件函数里引用的；而现在引用的位置放到了顶层而不是函数里，这样就需要在 createApp 之前手动设置一下 pinia 实例，而不能 createApp 完了之后再 app.use。

## 2023-02-01

正在尝试给 store 添加东西了。

首先添加的是 servers，为此引入了之前的几个 bridge。在以前的代码里，使用了 remote、process 这种在现代 electron、浏览器中不受支持的 API，因此也对相关的函数做了小幅更改。

另外就是遇到了一个 vite 相关的文件引入问题，已修改配置解决。还剩下的一个问题是 vite 似乎读不到 EventEmitter。

## 2023-02-02

在渲染进程中，因为开启了一些 electron 的隔离功能，所以不能用 node 的 EventEmitter。昨天的问题是这个。引入 events 库就好了。

往 store 中加入了添加服务器和任务的功能，尚未做服务器事件监听，因此服务器中的数据目前传不到前端。得考虑开始做模块化了。

## 2023-02-08

把 MainFrame 中 container 里的东西拆成四大块之后，终于能“清爽”地进行接下来的开发了。
（其实前几块的铺垫都是为了搞 01-23 所说的任务项 TaskItem，想直接把 store 中的数据通给它做渲染）

这次的主要难点在于引入 jsx。首先引入 @vitejs/plugin-vue-jsx 的作用就是给 vite 引入一个 babel 做转换（大致是这么回事），但对功能以外的东西它并不关心。于是我就遇到了两个问题：eslint 和 ts。
对于 eslint，解决方案是增加 parser 和 parserOptions 字段；
对于 TypeScript，解决方案是 jsx 字段值改为 "preserve"。另外，不能使用 React 特有的“className”之类的属性，这个在 vue 文档中就有说到。

另外也大致明白了 jsx 在 vue 中担任怎样的角色。实际上，vue 本身就支持直接用 js 而不是模板语法写组件，其中就包括了 class component 和 function component。jsx 插件只是把其中的 jsx 转换成 h 函数而已。另外，这个插件不仅对 .jsx、.tsx 生效，甚至对 .vue 也生效，也就是可以在 `<script>` 标签中写 jsx 组件给 template 用。

## 2023-02-10

02-02 中写到，目前还没有做后端消息的 handler，所以传不到前端。因此目前在做的就是 serverEventsHandler。

在之前，由于使用 VueX，mutations 要调用另一个 mutation 是不行的，得用 mainVue 这种比较 hack 的方式。现在用 Pinia 之后直接 useStore 就行了。
不过 initializeServer 函数里有个地方需要 as Server。怀疑 Pinia 对它做了点转换，导致这个数据实际上是被深拷贝了一份，但目前不确定是不是这么回事（也有可能只是 ts 做了下转换），因此需要先把前后端通讯打通，验证这个问题。

打通前后端的过程中，因为涉及到具体的运行逻辑了，需要把 nodeBridge 的一些功能也做下适配（包括 preload），目前正在进行中。

## 2023-02-11

接通后端的过程比较顺利，几乎是一接通就能用了，很好。
（而且还能用老 FFBox 起服务器，在目前还没改后端数据结构的情况下，直接就开箱即用了）

然后是关于 nodeBridge 适配的问题。过往的代码中，renderer 还是带了很多跟 electron 或者 node 相关性比较大的代码，比如说直接在渲染进程 spawn 一个进程、用 remote 去 flashFrame 或者 openDevTools 等。为了实现分离，最好的方法是页面要假设不知道下层是 electron，所以这些功能就得都集合到 nodeBridge 里，而 nodeBridge 对接的 preload 也直接改成了 `jsb` 这个名字。

下一步就是 taskItem 的设计了。目前完成了 tasklist 的分离，仍需继续制作。

另外，目前的列表刷新机制好像会导致 vue 出现 internal bug，具体还需继续排查。

## 2023-02-14

今天先写了一下 taskItem 里参数展示的样式，然后为了使用 videoRateControl 这类 computed 值，排查了一下 internal bug 的原因。
猜测是因为我给 v-for 的 key 传了个对象，猜测正确。
于是找了一下以前的解决办法，是另有一个 computed 值，把 id 插入到列表中的每一个项。这个做法，是为了节省一个字段，😂很有“个性”🤔。

另外，如果使用了 computed，console 中出现了 `Invalid VNode type: undefined (undefined)` 的 warning，可能是由于忘记取 .value 所致。Vue 的错误提示在这点上十分不友好。

目前设计了四项信息展示，但此时的列表宽度已经非常高了，导致文件名没什么位置放。尝试使用老版 FFBox 的多行溢出属性，没成功，得后面继续调。

## 2023-02-15

继续调整 taskItem 的样式，加入了左侧图标和右侧操作按钮。
同时参照老版 FFBox 的 taskItem 设计重新实现阴影。当年为了实现个阴影套了几层 div，确实是对视觉效果的要求很高🙈。
比现在调半天还丑不拉几的我艺术感好多了。

## 2023-02-21

继续实现 taskItem 的功能，加入了 dashboardArea 和 cmdArea。Of course 所有按钮都还没做响应，然后根据元素宽度自动开关和伸缩某些字段的功能也还没做，所以现在看起来还是不太顺眼的状态。

途中发现了 CSS :has 选择器，直到去年 8 月才在 chromium 上线。这叫及时雨。

## 2023-02-22

往 store 中加了几个界面类的属性，还没写功能。因为静态界面开发太久了，想看看它交互起来怎么样。
于是着手去改一下 ParaBox 的设计。首先是分了文件，然后要把里面的 sidebar-icon 都换成 svg。
但就卡在了 svg 这一步：

### 样式异常

使用 Ai 直接导出 svg，样式会以内部 CSS 形式被放到 `<defs><style></style></defs>` 里去。而 vite-plugin-svg 将其转换为 vue 组件的时候，由于 vue 不支持在组件中使用 `<style>`，所以样式会被去掉。在 vite-svg-loader 的 issues 中，有两种解决方案：

- [链接](https://github.com/jpkleemans/vite-svg-loader/issues/56#issuecomment-1160290025) 中提到，可以在 svgo 设置中启用 inlineStyles 插件，把样式从 `<style>` 中移动到标签内联。但实际上，阅读文档后发现，vite-plugin-svg 默认就启用了 svgo 的默认设置。而默认设置中就启用了这个插件，但插件有 bug，没把样式应用到全部标签上，只会应用一次。这个 [bug](https://github.com/svg/svgo/issues/1743) 在一个月前才被提出。
- [链接](https://github.com/jpkleemans/vite-svg-loader/pull/92) 处，有人提了一个 PR，把 `<style` 替换为 `<component is="style"`。同样是在一个月前才被提出。

vue 的生态可谓是非常奇怪，发展了很久，但总是会遇到些新鲜热辣的问题，得等社区解决。

不过在上面提到的第一点中，下面的评论有提到，可以给 inlineStyles 设置 `onlyMatchedOnce: false` 解决。你说这是个 bug 呢还是个 feature 呢 = =。

如果排除上述解决方案，从 Ai 本身入手的话，就得在导出时设置样式为内联样式。这样一来会导致文件明显变大，另外要通过修改导出设置来兼容程序，说明这个工程的兼容性不好，所以不这么做。

不清楚把 vue template 换成 jsx 会不会有这个问题，明日再试。

### 颜色应用

在其他比较常见的 svg 中，整个图形是一个路径，使用 `fill="currentColor"`，就可以实现外部使用 CSS 自定义颜色。

而在 Ai 中导出 svg，它是带了一个颜色的。有如下几种解决方案：

- 在 Ai 里清除掉这个颜色。这当然不考虑，因为这样的话在 Ai 里直接就看不到了。
- 对每个使用颜色的地方使用 CSS `!important`。彳亍，只是我不太喜欢。（要是解决了 style 标签被 vue 吞了的问题，就不需要这样做了）
- 修改每个 svg 文件，把 stroke 手动改为 `stroke:currentColor`。麻烦点，可以减少文件体积。

## 2023-02-23

jsx 依然无法解决 style 标签被 vue 吞掉的问题。另外，jsx 若要给一个包在 `{}` 中的组件设置样式等属性，就需要用到 h 函数了，没有 vue template 那么“原生”。所以还是暂时换回 vue SFC。

另外，解决完上述所有问题之后，“输入”和“输出”图标依然是不正常的。这个锅我认为得让 Ai 背。因为这俩图形是使用路径 + 填色做出来的，Ai 导出后对应的填色标签上并没有任何属性，需要手动写一个 `.cls-3{fill:currentColor;}`，给标签加上这个 class 才行。另外，这种图形在 Ai 里也无法设置复合路径。

解决了 svg 的问题后，继续调整 devider 的样式，加上了全局参数的展示器及展开/折叠按钮，给 devider 加上了拖拽调整高度，顺便做了少量读屏器适配。

## 2023-02-26

补充了一些内容，包括 TaskItem 的“预计剩余时间”占位、其 cmd 选项卡的点击响应及样式优化、Parabox devider 的切换。做到这一步，就要考虑引入 Parabox 了。

Parabox 的引入是个大项，因为一下子就要把许多东西引进来，包括子参数盒页面、所使用到的控件、控件里所使用到的 Tooltip。普通控件需要对它做 vue2 选项式 API 到 vue3 组合式 API setup 的转换，Tooltip 则还需要去看如何凭空创建一个 Vue 组件出来。
本打算按照老经验去看一下 Element Plus 是怎么写的，结果 npmmirror 服务器 502 了装不下来，便去 GitHub 直接看代码。发现它的设计似乎比以前复杂了许多，还没时间去弄懂它，只看到了一些最基础需要用到的代码。
然而，引入之后，一方面是遇到了文件引用未找到的问题（暂时通过移动文件解决），另一方面，解决完其余问题之后，Tooltip 依然是不出现的。还得继续去找原因（有可能是漏了某行 context 的代码）。
已经找到了文件引用未找到的问题的原因。vite 配置中 resolve 漏了 tsx 的文件后缀。

## 2023-03-06

上次的问题，Tooltip 不出现的原因是，vnode 的 props 是个只读属性，直接修改是不行的，需要使用 vnode.component.props 进行修改。简单来说，在 DOM 上新增元素挂载 Vue 组件的方法分为三步：1. 使用所需组件创建 VNode。2. 创建 DOM 节点。3. render。
显然是对 Vue3 的原理不太熟悉，还需后期继续学习。

另外，解决问题的过程也没有一帆风顺，其中就遇到了 dev 模式弹不出来窗口的问题和编译失败的问题。dev 模式出不来窗口是个低级问题了，把 debugger 语句留在了 first render 里；编译失败则依然是 vite 的问题，在编译模式下，尽管跟开发模式使用同一份 config，但生产模式下，resolve alias 读不到，需要使用 path.resolve。

还发现了 Vue 2 到 Vue 3 的一处不同：Transition 组件所使用的 CSS 名称发生了变化。变换起始的类名后面增加了“-from”。解决了组件迁移后只有部分动画的问题。

## 2023-03-09

最近一段时间在迁移 Parabox components，目前已经基本上迁移完成了，不过由于还没打通前端到后端的参数传输，所以看不到实现效果对不对。回看日志可知，做这块工作的目的是为了尽快完成软件主要界面的功能。为了继续开发，下一步就需要去写参数传输到后端的这些逻辑了。

正在做参数的保存。因为有了 Pinia，所以简化了一下设计，直接修改 globalParams 然后通知 store 去做应用就行了。此时就遇到了需要使用 electron-store 的场景。
由于打开了安全设置，在渲染进程中，getEnv 始终会返回 browser，故考虑在 preload 引入。
但 preload 引入其实也是不行的。根据[这个 issue](https://github.com/sindresorhus/electron-store/issues/228)，preload 只允许导入少量 electron 功能。所以存储的功能还是得让 jsb 去做。
同时，nodeBridge 也是可预见到的要大改。因为 nodeBridge 是按照原来可以直接在渲染进程获取到 node 模块的方式设计的。现在很多东西都要用主进程去做，所以得改。
另外，做 electron-store 的适配也并非一帆风顺。比如中途就遇到了调用 ipc 的时候报错 `An object could not be cloned.` 的问题，这是个无厘头的错误，解决方案是刷新一下页面。彳亍，vite 的 HMR 还是有点 bug 在的。

## 2023-03-12

为了测试参数盒的运行效果，还需要让任务可被选择。因此最近给它补上了任务选中的相关逻辑，设计了一下样式进行适配。可喜可贺，这块工作一次便成功。

## 2023-03-15

完成上述工作之后，下面就该把参数盒的东西补全了。目前正在进行第一个模块 VcodecView，做到 rateControlList 的时候，涉及到一些逻辑操作，而目前的 vcodecs 还是 js，需要把它转换成 ts 才好操作。同时也进行了一些 var -> let/const 以及可选链等等的优化。
AcodecView 也照猫画虎照葫芦画瓢做好了，由于东西比 VcodecView 少，所以 acodecs 可以不转 ts，只会产生 1 个错误。不过，这种做了一半的不对称开发必是我不接受的，明天就把 acodecs 也转 ts ╮(￣▽￣)╭。

And，在做第二个参数盒之后，我顺便也把 transition 给重做了。现在看 Vue 文档显然比 4 年前看文档要少吃力，所以终于会用 transition 做条件动画效果了，做了点细致调整。主要是由于把上下动画换成了左右，跟阅读方向平行，如果还按原来那种速度和幅度左右渐变，似乎没那么舒服（感觉在抽动视线），所以对进出的动画动单独调整了。

另外，之前遇到的 `An object could not be cloned.` 现在可以稳定复现了。这次是出现在 set 的时候。Proxy 无法直接 ipc 到主进程，需要 JSON.parse(JSON.stringify) 一下。

除此以外，目前也发现了 Slider 组件不能按预期工作（估计是坐标检测问题）。后续会把它的问题修正。

## 2023-03-16

完成了剩余参数盒的设计，包括 acodecs 的 ts 转换。ShortcutView 我也想到了 RadioList 的设计。

修正了 Slider 和 Checkbox 的 bug、三个 View 没写对参数的地方。

列完待办项后，打算做添加服务器。然后在思考界面设计的过程中，发现了全局参数的 TextField 是写死的数据。将其转换为真实数据的过程中发现 upath 故障。经过对它源码的查看后，发现它里面有一些方法是直接调了 node 的，在 web 环境中就会失效。所以考虑使用 path-browserify 给它做一下 polyfill。

结论是：upath 并不带有浏览器环境的支持。虽然可以通过安装 path-browserify 在浏览器中使用 path，但 upath 并不具有任何可以传入 polyfill 的设计，其内部调用都是假设能 require 到 path 来设计的。在 npm 里找到的没有文档的 upath2 也是同理，均无法使用。
为什么要用 upath 呢？因为它附带了 trimExt 等等 path 里没有的函数。所以我在 utils 里手动拷贝了它的源码，改了一部分，才成功启用。
只不过这样并不优雅。本来能用 upath 一个模块解决的事情要分到 path-browserify 和 utils 里，而且类型检查也不完备了。
但在目前 upath 作者停止维护的情况下，只能先这么做，以后再考虑把它收拾干净。

### 待办项：

- TaskItem 的多种视图模式。其中详细模式根据参数自动控制显示列，根据运行状态显示 dashboard（可考虑完成之后这里变成图表，后续的事情了）
- ShortcutView 的存储实现
- 按名称搜索功能（粤语）（后续加上按分辨率、格式之类的筛选功能）
- 任务开始、任务上传
- 大按钮菜单（打赏中心、设置（包括夜间模式、单位））
- 预计剩余时间
- **添加服务器按钮（包括本地服务器未加载出来时的样子）**
- 关闭软件二次确认
- 底栏状态信息（加入网速信息）
- **msgbox**、popup

## 2023-03-18

关于添加服务器的登录界面要长什么样式，我想了一个大致方案：做一个蒙层放在 ListView 的上面。同时，服务器断线也要有这么个蒙层在上面。
那既然都是蒙在这个地方，不如就顺便重新设计一下 ffmpeg 未找到的样式好了。
一开始是想到了一个 ffmpeg 图标后面加几个点和问号。但这个设计方案总感觉有点太过正经，作为一个个人软件没必要这么拘谨，便想用一些表情包的图放上去。然后想到了“快乐，啪，没了”，用 AI 做一下描摹之后发现根本看不出来形状了，于是改用小蓝。小蓝并没有一个官方图库，只能在网上搜集尽可能清晰的图片，然后做放大，再交给 AI 描摹。预计在这个 commit 里会提交一版彩色的，在下一版去掉一些 fill 再提交。

另外，在思考蒙层形态的时候，我打算把它做成 Msgbox，不过 container 可以自行指定而不是默认全屏。这一步就涉及到设计一个适用于 Vue 3 的模态弹窗组件了。
一开始我没看 Element Plus 的源码，就按自己的认知来写，因为关于 button callback 要如何回传并且关闭弹窗这步，是要自己想的。
重点是关闭弹窗，~~老版 FFBox 实际上并没有做好相应的设计，因为当时写的 close 函数就是把**组件内**的 v-if 关掉，然后把之前被放进列表的 instance 从列表中去除。这其实就是当年 js 功底不过关的表现了，因为这个列表是自己声明的，组件卸不卸载并不取决于这个自定义的列表。换句话说，根本就没有 unmount。~~老版 FFBox 是先把组件内的 v-if 关掉，然后在 transitio 的 afterLeave 里 $destroy，然后找 parentNode removeChild。这个销毁自身的方式我想为什么在 Vue 3 被去掉了呢？我认为是，这个组件应该由控制创建它的地方去控制它的销毁。否则，如果它在节点树里出现，但它又被销毁了，那就有点奇怪了。
另外，老版弹窗没有异步操作设计，点完按钮就 close，这个设计也并不够现代。

为了解决卸载问题，我去搜了一下 Vue 3 如何卸载组件。得到的结论是 `render(null, container)` 就可以了。我总觉得不放心，这样解绑是解绑了，会不会把 container 里的所有组件全给清掉？VNode 还在不在？
我在组件里加了个定时器，对比点击卸载前后的 props 变化。结论是：没有变化。
我尝试在组件里读取 context，看下点击卸载之后里面的 context 会发生什么变化，然而 script setup 本身就不太能拿到完整的 context（也就是说拿到的可能至少也是被裁剪的 context，而不是原来的 context）。
最终在组件里面写了个 onBeforeUnmount，发现点击卸载的时候这个函数会被触发。那彳亍，既然你 Vue 说卸载了，那我也就认为卸载了吧。
至于 Element Plus，我后来看了下它的源码，感觉相比于 Tooltip，它的改动没有那么剧烈，还是能看到以前的一些影子的，比如说那个 instance 列表。至于它是怎么 unmount 的，因为它用了 Element Plus 的 hook，那块我没细看了。但估计也是控制里面的 v-if 关闭，等动画结束之后就 unmount 吧，不清楚了，反正现在可用了，可以去设计它的样式了。

## 2023-03-19

昨天在做 Msgbox 的时候，又遇到了尤雨溪生态的一个问题，服[抱拳]
这个问题是，在 `<script setup>` 里使用 defineProps 指定类型的时候，不能使用导入的类型，或者 type，否则 vite 报错。如果不指定类型，那么 vue 层面上也接收不到 props。
就很神奇，为什么 js 层面上运行的东西要去管用于代码提示的 ts 呢？
根据这个[issue](https://github.com/vuejs/core/issues/4294)，装上 vite-plugin-vue-type-imports 之后可以解决使用导入类型的问题。但这种东西，竟然到现在还没被正式纳入 vue 中，太奇怪了。

今天就遇到了另一个应该跟尤雨溪没有关系的 bug。在 devTools 选中元素的时候，概率（按组件）性触发像 `[31216:0319/183752.527:ERROR:CONSOLE(0)] "[formatjs Error: MISSING_VALUE] The intl string context variable "REASON_PROPERTY_DECLARATION_CODE" was not provided to the string "请尝试移除 {REASON_PROPERTY_DECLARATION_CODE} 或更改其值。"", source:  (0)` 这样的报错，同时样式窗口不更新，没法调节样式。谷歌上完全找不到类似的问题。但根据它报错的位置来看，应该是 electron 的问题。把 electron 版本更新到 23 后问题解决。

说没又有了。vite-plugin-vue-type-imports 虽然能解决部分问题，但那是在 vite dev server 启动成功后新写的内容可以用，要是把 dev server 关掉再打开，vite 就卡死了（Ctrl C 都没反应）。直接 build 也会卡死。
于是试着不要用 SFC 了，换用 tsx。问题解决。
这还是头一次遇到 template 完全无法解决的问题，还得借用 React 的魔力。
