# 开发模式

vite server 启动后端（如端口占用，退出返回错误码），后端安静地等待接入。
vite server 启动前端，dev 模式下前端启动后端的逻辑改为手动点击按钮输入 pid。相关操作由 main 来控制，通过 ipc 发送给 renderer 结果。

# 生产模式

1. webpack 打包后端
1. vite 打包 electron main
1. vite 打包 electron rendrerer
1. vite 打包 electron preload
2. electron builder 产出可执行包，复制后端 exe 到目录
3. 手动打 Windows 安装包

# 开发日志

## 2022-12-11

确定了项目模块与打包器对应的大致逻辑。

已实现使用 webpack 对 backend 的 Hello world 进行打包，@common 也可打包进程序，并使用 pkg 生成 exe。后期需引入 koa 一系列东西去测试能否正常打包。

正在尝试调试 backend。目前已实现使用 webpack 打包（带 source-map）完成后再使用 vscode 对生成文件进行调试。仍需探索使用 vite devServer 的方式而不是 webpack 输出文件。如果确实不行，这样分两步也没太大问题，不过最好有个脚本可以合并这个操作。

[这里](https://stackoverflow.com/questions/66147328/is-there-a-way-to-debug-code-in-vscode-initiated-with-vite)有人说可以用 vscode 调试 vite 打包的项目。

## 2022-12-12

vite devServer 无用了，因为找不到一种方法，可以让 vscode 启动调试任务时，让 vite 启动一个 devServer 进行 HMR 编译。vite CLI 可以启动 devServer 服务，但是它不进行编译。vite Node API 可以编译，但代码逻辑只是让它感知到代码变化后重新 build 到 app/backend 里去，编译输出的文件跟 server 似乎没什么关系。

所以干脆就做成在 vscode 里启动调试之后，先用 vite CLI 进行 build，等完成之后用传统方法启动一个 vscode 调试任务（启动 js，map 到 ts）。同样的，webpack 也能实现这个功能。于是就做了 vite 和 webpack 两套方案。

下一步应该是要先打通引入了 koa 之后的 backend 输出到 exe（不急着写脚本）。然后写使用 vite 进行 electron Hello world 开发的脚本。这一步理论上不太难，因为已经有别的框架打了模板。
如果确实要做 HMR 的话，vscode 的文档里有指南。这里放一个 vue 的[链接](https://github.com/microsoft/vscode-recipes/tree/main/vuejs-cli)。

## 2022-12-13

引入了部分 koa 之后，vite 直接成功，webpack 下 formidable 会出运行时错误，需要根据[链接](https://github.com/node-formidable/formidable/issues/337)手动配置 hexoid 路径才成功，原因未知。

## 2022-12-16

打开所有了后端代码之后的运行都成功了。vite 依然是一次成功，webpack 则卡在了 ws 库上。依然没去探寻默认值下打包失败的原因，不过[这个地方](https://github.com/websockets/ws/issues/1538)基本包含了全部的解决方案。可以用 resolve 强行把入口指向 node_module 下的文件，也可以换个导入方法（改代码）。

## 2022-12-17

增加了用于 renderer、preload、main 的 vite 配置，dev-frontend 和 build 基本上都是一次成功。只是稍微研究了下导入路径。已经实现引入 vue3 Hello world 之后使用 dev 模式启动。

目前 vite:renderer 这步只差 index.html 的编译就能导进 electron-builder 了。

下一步就应该去设计 interface 和主控逻辑了。目前还没想好从哪开始做起。目前可知的是，按之前想过的内容，应该要构思一下如何做两边的连通。比如说生产环境下直接 spawn，开发环境下……不知道……

## 2022-12-18

连通方式大致是：生产环境下直接 spawn，开发环境下启动一个 node --inspect 或者 --inspect-brk。这样，在 FFBox 启动后将自动启动一个 backend，此时只需要在 vscode 使用 attach 模式进入调试就可以了。launch.json 已经增加了 attach 模式，剩下的就是后续在 main 里 spawn 一个 node 了。

index.html 这步也已完成。把 config 中的 lib 去掉就可以了。导进 electron-builder 打包之后能直接启动。

因为该版本需要考虑 preload，所以也进行了 preload 的尝试。目前也已成功将 preload 里的 electron API 引入 renderer 里使用。不能直接把整个 API 对象导出来，需要细分到里面的方法，因为导出整个 API 的话里面就包含了一些不是 JavaScript 上下文的东西。

renderer 方面，引入了 jsx，还没尝试能不能用。

## 2022-12-19

开始了界面的设计，正在设计整体框架。less 引入直接成功，零配置。

## 2022-12-20

volar 扩展似乎安装成功了。之前用的一直是 v0.36，即使重装插件也是 v0.36，直到关闭所有页面升级 vscode 后才装上了 v1。此前 .vue 文件是没有代码提示的。

## 2022-12-23

加入了 256px 无边距透明的 logo，适配了无边框样式的一些细节。

## 2022-12-24

研究了一下 box-shadow 的渐变机制，发现 W3C 并没有对使用何种算法渲染阴影有规定。因此我测试出来，chromium 的阴影并不线性，只能知道阴影最远向外扩散到多少像素，至于向内，阴影浓度很快就接近 100%，但直到超过了指定像素一小段距离才真正达到 100%。

做这个测试是因为今天给 FFBox 引入了无边框，正在给 FFBox 标题栏增加 tabs，ActionBar 上的那一道亮光导致了 tabs 跟 ActionBar 的过渡并不柔和。

另外，做了一下三大金刚键的一部分，然后就去捣鼓怎样引入 svg 了。默认的引入方式是 img 标签，但这样无法控制颜色，因此还是需要一个 loader。npm 上搜到的第一个便是，虽然看起来挺方便易用，但是我马上发现了一个 [bug](https://github.com/jpkleemans/vite-svg-loader/issues/86)。vite 对 vue 的社区支持明显是比 react 好很多，之前在做 ttqftech 的 svg 引入时，搜了很久也只能找到一个略有点不优雅的方案。

## 2022-12-28

确定好了初期 menu 要放什么东西进去。同时也实现了三大金刚键的功能。

另外，electron 已经支持了 window overlay，可以把 Windows 三大金刚键做到窗口上，如果调好了的话就可以使用 Win11 的快速分屏小工具了，缺点是不能移动位置。

目前不打算把它做进去，只是用自己的实现。我的主要诉求骑士是拖动标题栏就能实现分屏等的基础效果。实际上，只要把 transparent 关掉就可以了。按目前的 UI 设计来说，也没有一定需要该窗口透明才能实现的东西，因此就这么用了。

## 2022-12-29

继续优化了一下 tab 按钮和三大金刚键的阴影效果。

## 2022-12-30

补充了参数面板的相关设计，包括六个按钮和全局参数的布局关系，仔细调整了面板和按钮的阴影。另外，动作栏也加上了“添加任务”按钮（样式待优化），后期在中间加上搜索框就完整了（4.0 暂时不做提示功能）。

参数盒里的控件是动态渲染出来的，所以稍后再做。下一步需要设计的是任务项的样式。完了之后就该尝试加上 pinia，给界面分文件了。

## 2023-01-23

任务项要长成什么样子，这个其实想了很久。而且任务项本身包含的东西比较多，如果要像 v1.0 那样，把东西先用 HTML hardcode 进去，也不是不行。但这样后期就得再做适配，时间成本上可能不如我先把工程化做好一点，接入实际数据更好。

另外，由于我对我自己目前设计出来的界面并不满意，也对自己每天排满活的行为并不满意，所以停了一段时间。

git 提交的节奏还是做不到瞬间转变，所以要在一次提交里包含比较多的东西。这次由于已经拖了一段时间了，所以干脆就直接先把 pinia 弄了，做一下工程化。

因为技术栈发生了 Vue 2 -> Vue 3，VueX -> Pinia，时序上有些变化。index.ts 里的 setActivePinia 就是变化的体现。在之前的版本里，VueX 是插入到 Vue 里，在组件函数里引用的；而现在引用的位置放到了顶层而不是函数里，这样就需要在 createApp 之前手动设置一下 pinia 实例，而不能 createApp 完了之后再 app.use。

## 2023-02-01

正在尝试给 store 添加东西了。

首先添加的是 servers，为此引入了之前的几个 bridge。在以前的代码里，使用了 remote、process 这种在现代 electron、浏览器中不受支持的 API，因此也对相关的函数做了小幅更改。

另外就是遇到了一个 vite 相关的文件引入问题，已修改配置解决。还剩下的一个问题是 vite 似乎读不到 EventEmitter。

## 2023-02-02

在渲染进程中，因为开启了一些 electron 的隔离功能，所以不能用 node 的 EventEmitter。昨天的问题是这个。引入 events 库就好了。

往 store 中加入了添加服务器和任务的功能，尚未做服务器事件监听，因此服务器中的数据目前传不到前端。得考虑开始做模块化了。

## 2023-02-08

把 MainFrame 中 container 里的东西拆成四大块之后，终于能“清爽”地进行接下来的开发了。
（其实前几块的铺垫都是为了搞 01-23 所说的任务项 TaskItem，想直接把 store 中的数据通给它做渲染）

这次的主要难点在于引入 jsx。首先引入 @vitejs/plugin-vue-jsx 的作用就是给 vite 引入一个 babel 做转换（大致是这么回事），但对功能以外的东西它并不关心。于是我就遇到了两个问题：eslint 和 ts。
对于 eslint，解决方案是增加 parser 和 parserOptions 字段；
对于 TypeScript，解决方案是 jsx 字段值改为 "preserve"。另外，不能使用 React 特有的“className”之类的属性，这个在 vue 文档中就有说到。

另外也大致明白了 jsx 在 vue 中担任怎样的角色。实际上，vue 本身就支持直接用 js 而不是模板语法写组件，其中就包括了 class component 和 function component。jsx 插件只是把其中的 jsx 转换成 h 函数而已。另外，这个插件不仅对 .jsx、.tsx 生效，甚至对 .vue 也生效，也就是可以在 `<script>` 标签中写 jsx 组件给 template 用。

## 2023-02-10

02-02 中写到，目前还没有做后端消息的 handler，所以传不到前端。因此目前在做的就是 serverEventsHandler。

在之前，由于使用 VueX，mutations 要调用另一个 mutation 是不行的，得用 mainVue 这种比较 hack 的方式。现在用 Pinia 之后直接 useStore 就行了。
不过 initializeServer 函数里有个地方需要 as Server。怀疑 Pinia 对它做了点转换，导致这个数据实际上是被深拷贝了一份，但目前不确定是不是这么回事（也有可能只是 ts 做了下转换），因此需要先把前后端通讯打通，验证这个问题。

打通前后端的过程中，因为涉及到具体的运行逻辑了，需要把 nodeBridge 的一些功能也做下适配（包括 preload），目前正在进行中。

## 2023-02-11

接通后端的过程比较顺利，几乎是一接通就能用了，很好。
（而且还能用老 FFBox 起服务器，在目前还没改后端数据结构的情况下，直接就开箱即用了）

然后是关于 nodeBridge 适配的问题。过往的代码中，renderer 还是带了很多跟 electron 或者 node 相关性比较大的代码，比如说直接在渲染进程 spawn 一个进程、用 remote 去 flashFrame 或者 openDevTools 等。为了实现分离，最好的方法是页面要假设不知道下层是 electron，所以这些功能就得都集合到 nodeBridge 里，而 nodeBridge 对接的 preload 也直接改成了 `jsb` 这个名字。

下一步就是 taskItem 的设计了。目前完成了 tasklist 的分离，仍需继续制作。

另外，目前的列表刷新机制好像会导致 vue 出现 internal bug，具体还需继续排查。

## 2023-02-14

今天先写了一下 taskItem 里参数展示的样式，然后为了使用 videoRateControl 这类 computed 值，排查了一下 internal bug 的原因。
猜测是因为我给 v-for 的 key 传了个对象，猜测正确。
于是找了一下以前的解决办法，是另有一个 computed 值，把 id 插入到列表中的每一个项。这个做法，是为了节省一个字段，😂很有“个性”🤔。

另外，如果使用了 computed，console 中出现了 `Invalid VNode type: undefined (undefined)` 的 warning，可能是由于忘记取 .value 所致。Vue 的错误提示在这点上十分不友好。

目前设计了四项信息展示，但此时的列表宽度已经非常高了，导致文件名没什么位置放。尝试使用老版 FFBox 的多行溢出属性，没成功，得后面继续调。

## 2023-02-15

继续调整 taskItem 的样式，加入了左侧图标和右侧操作按钮。
同时参照老版 FFBox 的 taskItem 设计重新实现阴影。当年为了实现个阴影套了几层 div，确实是对视觉效果的要求很高🙈。
比现在调半天还丑不拉几的我艺术感好多了。

## 2023-02-21

继续实现 taskItem 的功能，加入了 dashboardArea 和 cmdArea。Of course 所有按钮都还没做响应，然后根据元素宽度自动开关和伸缩某些字段的功能也还没做，所以现在看起来还是不太顺眼的状态。

途中发现了 CSS :has 选择器，直到去年 8 月才在 chromium 上线。这叫及时雨。

## 2023-02-22

往 store 中加了几个界面类的属性，还没写功能。因为静态界面开发太久了，想看看它交互起来怎么样。
于是着手去改一下 ParaBox 的设计。首先是分了文件，然后要把里面的 sidebar-icon 都换成 svg。
但就卡在了 svg 这一步：

### 样式异常

使用 Ai 直接导出 svg，样式会以内部 CSS 形式被放到 `<defs><style></style></defs>` 里去。而 vite-plugin-svg 将其转换为 vue 组件的时候，由于 vue 不支持在组件中使用 `<style>`，所以样式会被去掉。在 vite-svg-loader 的 issues 中，有两种解决方案：

- [链接](https://github.com/jpkleemans/vite-svg-loader/issues/56#issuecomment-1160290025) 中提到，可以在 svgo 设置中启用 inlineStyles 插件，把样式从 `<style>` 中移动到标签内联。但实际上，阅读文档后发现，vite-plugin-svg 默认就启用了 svgo 的默认设置。而默认设置中就启用了这个插件，但插件有 bug，没把样式应用到全部标签上，只会应用一次。这个 [bug](https://github.com/svg/svgo/issues/1743) 在一个月前才被提出。
- [链接](https://github.com/jpkleemans/vite-svg-loader/pull/92) 处，有人提了一个 PR，把 `<style` 替换为 `<component is="style"`。同样是在一个月前才被提出。

vue 的生态可谓是非常奇怪，发展了很久，但总是会遇到些新鲜热辣的问题，得等社区解决。

不过在上面提到的第一点中，下面的评论有提到，可以给 inlineStyles 设置 `onlyMatchedOnce: false` 解决。你说这是个 bug 呢还是个 feature 呢 = =。

如果排除上述解决方案，从 Ai 本身入手的话，就得在导出时设置样式为内联样式。这样一来会导致文件明显变大，另外要通过修改导出设置来兼容程序，说明这个工程的兼容性不好，所以不这么做。

不清楚把 vue template 换成 jsx 会不会有这个问题，明日再试。

### 颜色应用

在其他比较常见的 svg 中，整个图形是一个路径，使用 `fill="currentColor"`，就可以实现外部使用 CSS 自定义颜色。

而在 Ai 中导出 svg，它是带了一个颜色的。有如下几种解决方案：

- 在 Ai 里清除掉这个颜色。这当然不考虑，因为这样的话在 Ai 里直接就看不到了。
- 对每个使用颜色的地方使用 CSS `!important`。彳亍，只是我不太喜欢。（要是解决了 style 标签被 vue 吞了的问题，就不需要这样做了）
- 修改每个 svg 文件，把 stroke 手动改为 `stroke:currentColor`。麻烦点，可以减少文件体积。

## 2023-02-23

jsx 依然无法解决 style 标签被 vue 吞掉的问题。另外，jsx 若要给一个包在 `{}` 中的组件设置样式等属性，就需要用到 h 函数了，没有 vue template 那么“原生”。所以还是暂时换回 vue SFC。

另外，解决完上述所有问题之后，“输入”和“输出”图标依然是不正常的。这个锅我认为得让 Ai 背。因为这俩图形是使用路径 + 填色做出来的，Ai 导出后对应的填色标签上并没有任何属性，需要手动写一个 `.cls-3{fill:currentColor;}`，给标签加上这个 class 才行。另外，这种图形在 Ai 里也无法设置复合路径。

解决了 svg 的问题后，继续调整 devider 的样式，加上了全局参数的展示器及展开/折叠按钮，给 devider 加上了拖拽调整高度，顺便做了少量读屏器适配。

## 2023-02-26

补充了一些内容，包括 TaskItem 的“预计剩余时间”占位、其 cmd 选项卡的点击响应及样式优化、Parabox devider 的切换。做到这一步，就要考虑引入 Parabox 了。

Parabox 的引入是个大项，因为一下子就要把许多东西引进来，包括子参数盒页面、所使用到的控件、控件里所使用到的 Tooltip。普通控件需要对它做 vue2 选项式 API 到 vue3 组合式 API setup 的转换，Tooltip 则还需要去看如何凭空创建一个 Vue 组件出来。
本打算按照老经验去看一下 Element Plus 是怎么写的，结果 npmmirror 服务器 502 了装不下来，便去 GitHub 直接看代码。发现它的设计似乎比以前复杂了许多，还没时间去弄懂它，只看到了一些最基础需要用到的代码。
然而，引入之后，一方面是遇到了文件引用未找到的问题（暂时通过移动文件解决），另一方面，解决完其余问题之后，Tooltip 依然是不出现的。还得继续去找原因（有可能是漏了某行 context 的代码）。
已经找到了文件引用未找到的问题的原因。vite 配置中 resolve 漏了 tsx 的文件后缀。

## 2023-03-06

上次的问题，Tooltip 不出现的原因是，vnode 的 props 是个只读属性，直接修改是不行的，需要使用 vnode.component.props 进行修改。简单来说，在 DOM 上新增元素挂载 Vue 组件的方法分为三步：1. 使用所需组件创建 VNode。2. 创建 DOM 节点。3. render。
显然是对 Vue3 的原理不太熟悉，还需后期继续学习。

另外，解决问题的过程也没有一帆风顺，其中就遇到了 dev 模式弹不出来窗口的问题和编译失败的问题。dev 模式出不来窗口是个低级问题了，把 debugger 语句留在了 first render 里；编译失败则依然是 vite 的问题，在编译模式下，尽管跟开发模式使用同一份 config，但生产模式下，resolve alias 读不到，需要使用 path.resolve。

还发现了 Vue 2 到 Vue 3 的一处不同：Transition 组件所使用的 CSS 名称发生了变化。变换起始的类名后面增加了“-from”。解决了组件迁移后只有部分动画的问题。

## 2023-03-09

最近一段时间在迁移 Parabox components，目前已经基本上迁移完成了，不过由于还没打通前端到后端的参数传输，所以看不到实现效果对不对。回看日志可知，做这块工作的目的是为了尽快完成软件主要界面的功能。为了继续开发，下一步就需要去写参数传输到后端的这些逻辑了。

正在做参数的保存。因为有了 Pinia，所以简化了一下设计，直接修改 globalParams 然后通知 store 去做应用就行了。此时就遇到了需要使用 electron-store 的场景。
由于打开了安全设置，在渲染进程中，getEnv 始终会返回 browser，故考虑在 preload 引入。
但 preload 引入其实也是不行的。根据[这个 issue](https://github.com/sindresorhus/electron-store/issues/228)，preload 只允许导入少量 electron 功能。所以存储的功能还是得让 jsb 去做。
同时，nodeBridge 也是可预见到的要大改。因为 nodeBridge 是按照原来可以直接在渲染进程获取到 node 模块的方式设计的。现在很多东西都要用主进程去做，所以得改。
另外，做 electron-store 的适配也并非一帆风顺。比如中途就遇到了调用 ipc 的时候报错 `An object could not be cloned.` 的问题，这是个无厘头的错误，解决方案是刷新一下页面。彳亍，vite 的 HMR 还是有点 bug 在的。

## 2023-03-12

为了测试参数盒的运行效果，还需要让任务可被选择。因此最近给它补上了任务选中的相关逻辑，设计了一下样式进行适配。可喜可贺，这块工作一次便成功。

## 2023-03-15

完成上述工作之后，下面就该把参数盒的东西补全了。目前正在进行第一个模块 VcodecView，做到 rateControlList 的时候，涉及到一些逻辑操作，而目前的 vcodecs 还是 js，需要把它转换成 ts 才好操作。同时也进行了一些 var -> let/const 以及可选链等等的优化。
AcodecView 也照猫画虎照葫芦画瓢做好了，由于东西比 VcodecView 少，所以 acodecs 可以不转 ts，只会产生 1 个错误。不过，这种做了一半的不对称开发必是我不接受的，明天就把 acodecs 也转 ts ╮(￣▽￣)╭。

And，在做第二个参数盒之后，我顺便也把 transition 给重做了。现在看 Vue 文档显然比 4 年前看文档要少吃力，所以终于会用 transition 做条件动画效果了，做了点细致调整。主要是由于把上下动画换成了左右，跟阅读方向平行，如果还按原来那种速度和幅度左右渐变，似乎没那么舒服（感觉在抽动视线），所以对进出的动画动单独调整了。

另外，之前遇到的 `An object could not be cloned.` 现在可以稳定复现了。这次是出现在 set 的时候。Proxy 无法直接 ipc 到主进程，需要 JSON.parse(JSON.stringify) 一下。

除此以外，目前也发现了 Slider 组件不能按预期工作（估计是坐标检测问题）。后续会把它的问题修正。

## 2023-03-16

完成了剩余参数盒的设计，包括 acodecs 的 ts 转换。ShortcutView 我也想到了 RadioList 的设计。

修正了 Slider 和 Checkbox 的 bug、三个 View 没写对参数的地方。

列完待办项后，打算做添加服务器。然后在思考界面设计的过程中，发现了全局参数的 TextField 是写死的数据。将其转换为真实数据的过程中发现 upath 故障。经过对它源码的查看后，发现它里面有一些方法是直接调了 node 的，在 web 环境中就会失效。所以考虑使用 path-browserify 给它做一下 polyfill。

结论是：upath 并不带有浏览器环境的支持。虽然可以通过安装 path-browserify 在浏览器中使用 path，但 upath 并不具有任何可以传入 polyfill 的设计，其内部调用都是假设能 require 到 path 来设计的。在 npm 里找到的没有文档的 upath2 也是同理，均无法使用。
为什么要用 upath 呢？因为它附带了 trimExt 等等 path 里没有的函数。所以我在 utils 里手动拷贝了它的源码，改了一部分，才成功启用。
只不过这样并不优雅。本来能用 upath 一个模块解决的事情要分到 path-browserify 和 utils 里，而且类型检查也不完备了。
但在目前 upath 作者停止维护的情况下，只能先这么做，以后再考虑把它收拾干净。

### 待办项：

- TaskItem 的多种视图模式。其中详细模式根据参数自动控制显示列，根据运行状态显示 dashboard（可考虑完成之后这里变成图表，后续的事情了）
- ShortcutView 的存储实现
- 按名称搜索功能（粤语）（后续加上按分辨率、格式之类的筛选功能）
- 任务开始、任务上传
- 大按钮菜单（打赏中心、设置（包括夜间模式、单位））
- 预计剩余时间
- **添加服务器按钮（包括本地服务器未加载出来时的样子）**
- 关闭软件二次确认
- 底栏状态信息（加入网速信息）
- **msgbox**、popup

## 2023-03-18

关于添加服务器的登录界面要长什么样式，我想了一个大致方案：做一个蒙层放在 ListView 的上面。同时，服务器断线也要有这么个蒙层在上面。
那既然都是蒙在这个地方，不如就顺便重新设计一下 ffmpeg 未找到的样式好了。
一开始是想到了一个 ffmpeg 图标后面加几个点和问号。但这个设计方案总感觉有点太过正经，作为一个个人软件没必要这么拘谨，便想用一些表情包的图放上去。然后想到了“快乐，啪，没了”，用 AI 做一下描摹之后发现根本看不出来形状了，于是改用小蓝。小蓝并没有一个官方图库，只能在网上搜集尽可能清晰的图片，然后做放大，再交给 AI 描摹。预计在这个 commit 里会提交一版彩色的，在下一版去掉一些 fill 再提交。

另外，在思考蒙层形态的时候，我打算把它做成 Msgbox，不过 container 可以自行指定而不是默认全屏。这一步就涉及到设计一个适用于 Vue 3 的模态弹窗组件了。
一开始我没看 Element Plus 的源码，就按自己的认知来写，因为关于 button callback 要如何回传并且关闭弹窗这步，是要自己想的。
重点是关闭弹窗，~~老版 FFBox 实际上并没有做好相应的设计，因为当时写的 close 函数就是把**组件内**的 v-if 关掉，然后把之前被放进列表的 instance 从列表中去除。这其实就是当年 js 功底不过关的表现了，因为这个列表是自己声明的，组件卸不卸载并不取决于这个自定义的列表。换句话说，根本就没有 unmount。~~老版 FFBox 是先把组件内的 v-if 关掉，然后在 transitio 的 afterLeave 里 $destroy，然后找 parentNode removeChild。这个销毁自身的方式我想为什么在 Vue 3 被去掉了呢？我认为是，这个组件应该由控制创建它的地方去控制它的销毁。否则，如果它在节点树里出现，但它又被销毁了，那就有点奇怪了。
另外，老版弹窗没有异步操作设计，点完按钮就 close，这个设计也并不够现代。

为了解决卸载问题，我去搜了一下 Vue 3 如何卸载组件。得到的结论是 `render(null, container)` 就可以了。我总觉得不放心，这样解绑是解绑了，会不会把 container 里的所有组件全给清掉？VNode 还在不在？
我在组件里加了个定时器，对比点击卸载前后的 props 变化。结论是：没有变化。
我尝试在组件里读取 context，看下点击卸载之后里面的 context 会发生什么变化，然而 script setup 本身就不太能拿到完整的 context（也就是说拿到的可能至少也是被裁剪的 context，而不是原来的 context）。
最终在组件里面写了个 onBeforeUnmount，发现点击卸载的时候这个函数会被触发。那彳亍，既然你 Vue 说卸载了，那我也就认为卸载了吧。
至于 Element Plus，我后来看了下它的源码，感觉相比于 Tooltip，它的改动没有那么剧烈，还是能看到以前的一些影子的，比如说那个 instance 列表。至于它是怎么 unmount 的，因为它用了 Element Plus 的 hook，那块我没细看了。但估计也是控制里面的 v-if 关闭，等动画结束之后就 unmount 吧，不清楚了，反正现在可用了，可以去设计它的样式了。

## 2023-03-19

昨天在做 Msgbox 的时候，又遇到了尤雨溪生态的一个问题，服[抱拳]
这个问题是，在 `<script setup>` 里使用 defineProps 指定类型的时候，不能使用导入的类型，或者 type，否则 vite 报错。如果不指定类型，那么 vue 层面上也接收不到 props。
就很神奇，为什么 js 层面上运行的东西要去管用于代码提示的 ts 呢？
根据这个[issue](https://github.com/vuejs/core/issues/4294)，装上 vite-plugin-vue-type-imports 之后可以解决使用导入类型的问题。但这种东西，竟然到现在还没被正式纳入 vue 中，太奇怪了。

今天就遇到了另一个应该跟尤雨溪没有关系的 bug。在 devTools 选中元素的时候，概率（按组件）性触发像 `[31216:0319/183752.527:ERROR:CONSOLE(0)] "[formatjs Error: MISSING_VALUE] The intl string context variable "REASON_PROPERTY_DECLARATION_CODE" was not provided to the string "请尝试移除 {REASON_PROPERTY_DECLARATION_CODE} 或更改其值。"", source:  (0)` 这样的报错，同时样式窗口不更新，没法调节样式。谷歌上完全找不到类似的问题。但根据它报错的位置来看，应该是 electron 的问题。把 electron 版本更新到 23 后问题解决。

说没又有了。vite-plugin-vue-type-imports 虽然能解决部分问题，但那是在 vite dev server 启动成功后新写的内容可以用，要是把 dev server 关掉再打开，vite 就卡死了（Ctrl C 都没反应）。直接 build 也会卡死。
于是试着不要用 SFC 了，换用 tsx。问题解决。
这还是头一次遇到 template 完全无法解决的问题，还得借用 React 的魔力。
有一点变啰嗦了：Transition 组件目前我还没找能较好适配 less module 的方法，不能像 template 组件那样传个 name 进去就能自动生成所有类名，而是要对每个类进行单独指定。等以后有空了再看看有没有简洁一点的。

## 2023-03-20

虽然 `03-18` 的开发日志里写了想把蒙层做成 Msgbox 的形式，但其实只是个样式上的设想。从逻辑上来说，我还是打算把它设计成一个普通的 div。先开发 Msgbox 主要是基于样式考虑，完成之后可以直接把样式拷贝过去。
因此周末主要时间花在了调 Msgbox 的样式上。调出来的结果我还是比较满意的。

另外，今天我也把 Msgbox 里的 Button 独立出来了。目前正在开发的是登录页面。

## 2023-03-21

做了些代码修改，以支持添加服务器的按钮，然后去做登录界面。
然后发现做出来的样子比较丑。于是给按钮加了点功能，支持小中大三种按钮尺寸。依旧没有解决丑的问题。

## 2023-03-22

给两个 InputBox 加上了边框，上面加上标题之后，丑的问题就解决掉了。
但在目前功能尚未完善之前，无法从界面上看到目前的状态。于是转而去做 TitleBar 的逻辑和样式了。
花了点心思去做背景颜色和阴影之类的细节，以及新增和关闭标签页时弹一下的动画。

大致思考了一下，FFBox 还需要一个掉线界面，于是我给它新增了一个 loading.svg。这个 loading 是我从 iconfont 上能找到的最均匀的了。什么意思呢？就是说我第一次找的 loading 让它转起来之后发现它有些杠画歪了 = =。另外，从网上找到的 loading 不会有转圈效果，我需要的是像秒针那样一格格动的效果，于是又手动改 svg——把它放到 AI 里释放复合路径——导出 svg，改颜色。然后在 animation 里加上 step 就行了。

## 2023-03-23

登录窗口和掉线提示这个花了好几个小时去做，因为没想好服务器的生命周期、几个窗口之间的显隐和堆叠关系，来来回回挪腾了好多遍才让它在正确的位置出现。再加上 vue template 非根组件不能用 Fragment，做到现在也仅是让它能渐变出来对应窗口而不能渐变退去。但是不弄了，就这样吧。

FFmpeg 缺失的提示窗很快就做出来了。感觉目前的样式还挺好看。

## 2023-03-24

完成了全局任务开始暂停的控制，及 TitleBar 上 Tab 进度条的样式。不过，那块的代码还没有用心去做，理论上应该把每个 Tab 独立成一个组件的，目前的逻辑我感觉有点低效。用性能监视器也能发现这个问题，就这一个 Tab 就把每秒的样式更新数从 20 升到了 60，同时 DOM 节点数还在不断增加（内存泄漏）。等有空了再去优化这里。

同时顺便给开始按钮加了个灰色的状态，在不能操作时给它禁用掉。

另外还需要做任务项里的进度。在做这一块之前，我打算先把 TaskItem 的样式先搞一搞，不要让它像现在那样显示一大坨。在我空闲的时候，我其实想过厕块要怎么做：遍历任务列表，只把有修改的值显示出来，以节约横向空间。同样，我感觉 Vue 不一定能按我的预期工作，于是我用 console.log 在计算的时候打印一下。好家伙，TaskItem 的每次进度更新都会把这个值重算一遍，这个造成的性能开销就有点大了，到时候再看看有没有方法把这个计算函数放到别处。反正这个函数的目的是为了更改 appStore.taskViewSettings，并不是要把它做成 computed 值。

## 2023-03-25

今天的工作量比较多。

首先是试了一下怎样才能让前一天所述的 changedParams 仅在实际发生变化时重算。使用 computed 或者 watch 的方案应该是走不通了，因为估计是任务进度更新涉及到 task，一串下来，vue 可能认为它邻居也发生了变化，于是重算。不过这仅是猜测，我目前还不清楚 Vue 是怎样认为依赖列表里的东西发生变化的，这个问题就有点像“react 子组件更新是否会导致父组件重渲染”一样。最后的解决方案是在 store 里新增一个 recalcChangedParams。至于这个函数什么时候要被调用，是挪腾过几次的。原来所认为够用的 boolean 也被改成三个值的枚举，因为要适配“禁用”和“不更改”的情况。
得益于可以隐藏部分参数，参数列表终于可以做得不那么紧凑了。

接下来，就去改了是否显示仪表盘的逻辑。以前定的是参数、仪表盘、命令行三个都可以单独让用户开关，现在看了一下，这样做会导致各种高度计算场合变复杂，所以就让仪表盘随任务状态开关，只留一个命令行让用户选择好了。

有了这两块改造，文件名终于可以不那么憋屈了，可以有更宽的空间。所以我给它加上了计算可用宽度的逻辑，以及是否放大文字和折行省略号显示的逻辑。

然后突发奇想让它适配超窄宽度屏幕（手机）。幸运的是因为以往写的时候就注意把平台特有功能分开，所以基本上搬到浏览器上直接就能用。不幸运的是发现移动端还有挺多问题。
比如说在 Chrome 里，画面底部被切掉了。可能是 Chrome 认为它的标题栏能随页面滚动被顶上去所以预留了这部分空间所致。
在夸克里，画面底部没被切掉，但是几乎所有颜色都不能显示了。看来是它版本太低，不支持 hwb 的缘故。
然后还有不论任何浏览器都有的一个问题：参数盒的拖动器不能用了。加上触屏事件监听之后会发现它能拖了，但是又点不了。touch 相关的事件里 preventDefault 似乎会屏蔽掉 click 事件；但不 preventDefault 的话，遇到夸克这种具有下拉刷新逻辑的浏览器，就会被浏览器行为给覆盖掉。至于 touchend，虽然能用，但是 css 按下的效果就会因为被 preventDefault 而不触发。最终决定用的是夸克不友好方案。

完成以上优化之后，终于能做任务项的进度条了。因为 linear-gradient 不支持动画渐变，所以使用多个进度条叠在一起控制透明度实现（跟前一天做的 TitleBar tab 同理）。这个并没有增加什么性能负担。另外，老 FFBox 的阴影样式直接搬过来之后有点丑，所以我又调了一下阴影，加了一些细致到 0.75 px 的阴影项。

最后试了一下整体效果之后，还想优化一下命令行那里，让它在用户滚到底时能保持最底。但是这个目前实现失败了，vue 监听不到命令行的文本变化（尽管渲染出来了）。初步估计是因为 cmdData 是个普通的 string，而不是响应式 Proxy 所致。我打印了一下 task，发现有好多属性是 Proxy，好多属性是普通值。这下有点难搞了，为什么有些值是 Proxy，有些值是普通值呢？响应式是在哪一步赋上的，在哪一步丢掉的？我感觉这又是 Vue debug 难以捉摸的一个点。

### 待办项：

- TaskItem 的多种视图模式、闪烁提示
- ShortcutView 的存储实现
- 按名称搜索功能（粤语）（后续加上按分辨率、格式之类的筛选功能）
- **任务上传和下载**
- 大按钮菜单（打赏中心、设置（包括夜间模式、单位））
- **预计剩余时间**
- 关闭软件二次确认
- 底栏状态信息（加入网速信息）
- popup
- 标签页性能优化
- 命令行界面自动滚动到底
- 各种 utils 整理
- 后端 progressLog 信息改造（前端自由选择截取多长的数组，以及数据无变更时不 push 列表）
- 通知机制改造（脱离 task）
- 重连服务器后要刷新列表

## 2023-03-28

03-25 那天，我花了 12.5 小时坐在电脑面前，其中大部分时间都在写 FFBox。这种程度的努力，也就只有大学时期能达到了吧。

实在不是很愿意在开发日志中写入这种个人的内容。可是我已经有不知多少年的时间，都没有一天在电脑面前坐超过 12 小时了。不同于当年的我在努力地追赶因学校课程和 onestop 被浪费的时光而去坚持做的事情，这次的 12 小时，更多的只是在如机器般消磨时光而已。

世间万物，仿佛来到我身边的，都陷入了持久的沉寂；或是经历了漫长的路途后，喜悦地来到了终点，然后发现是个断头路，前方再也没有去向。

整整两周，我都在埋头干。干公司的活，干 FFBox 的活。有限的任务就摆在眼前，我只想赶紧把它们干完，早点熬过这周，就能去广州玩一下了。

我每天都在等。每天都在等。

原来，哪怕希望再小，也是能破灭的。只要我在的地方，都会得到上天安排的神罚，阻止我或者我身边任何一个人去实现计划。

不止是广州，不止是一次。事情不多，可是，很多，很重。大至几百万，上千万的人，会因为我引起的暴雨、疫情而损失了我所看不到、统计不到的项目；小至一个人、几个人，会失去他们心心念念的旅程。

我不知道我要做什么。我的梦想，不是面对这些电脑，而是那些与人、与世界的一点一滴相关的事。FFBox，只是我“拯救世界”的一环，可面对这繁杂、无尽、野蛮发展的现实世界，它的存在变得十分地渺小。

还未复活的个人网站、尚未开始的播放软件、早已失去兴趣的直播升画质存档……哪个不是我心心念念的？

可我不是 CodeGPT，我是人类。可我只是被命运困在了一个半透明的空间内，只能偶尔能羡慕一下人类的生活。暂时，还不像一个人类，也看不见，什么时候，能当上一个人类。

---

最近两天，做的内容是文件的拖拽上传和下载。这块内容同时也会涉及到 dashboardTimer 的引入，也都做了。整体上还是比较顺利的。

## 2023-03-29

做了上传状态的 Dashboard 适配，增加了“文件大小”和“传输总量”这个仪表盘项，调了一下尺寸。下载的事件还没正确传回，所以能下载但是界面上没反应。

## 2023-04-03

下载事件传回代码迁移在 03-30 做到一半，就跑去广州了，简单解决了一下地球危机，2333。

剩下的内容在今天补完了。主要是需要在 App onMounted 里挂载事件。做了一点工程上的事情，将相关函数转移到了 eventsHandler 里面。另外，03-28 的日志里也没提到一点，就是将 dashboard 的相关函数整理到 dashboardCalc 里面。

另外，在进度那里增加了 size 一项。现在可以在转码过程中看到输出文件大小了。

## 2023-04-04

昨天在即将完成的时候，FFBox 突然出了点问题，导致前端 hwaccel 那里报错，后端无法开始任务。前端修复代码、把配置文件清空均无法恢复。结果拿老版 FFBox 运行一下就解决了。╮(￣▽￣)╭

今天开发的内容是“预计剩余时间”的显示。不过，为了开发这个功能，做了一些额外的改进。
首先，为了计算预计剩余时间，之前没做好的进度显示就需要优化，也就是需要在进度计算那里加一个通用函数用于计算按时间剪裁后的输出时长。
在做这块的过程中，由于涉及到时间表示字符串和时间数值这两者之间的转换，也需要做一个通用函数去进行。此前的 getTimeValue 只能处理一种时间格式。现在改名为 parseTimeString，按照 ffmpeg 对时间的识别逻辑进行了改造，且应用到 Inputbox 等地方。这样前端的计算结果就能与 ffmpeg 同步。
另外，老版 FFBox 可以显示媒体时长，新版我还没找到地方放进去。于是，我在 taskItem paraArea 那里开了个项，这样就能在一个地方显示输入时长和输出时长了。在做这里的时候，同时也优化了一些操作按钮和 paraArea 的位置，还有 divider 的插入逻辑。
以上内容开发完成之后，看到效果，感觉不错。看起来，软件的功能已经完成了 70% 了。

最后一点想实现的是 dashboard 的“时间”和“帧”按窗口宽度决定是否显示。由于涉及到计算文件名可用宽度的逻辑，窗口宽度需要在 js 层面上监听。监听是好解决的，但解除监听就难办了。TaskItem 使用 Functional Component 实现，它不能使用 onBeforeUnmount 这类钩子，因为它没有生命周期。
这就导致了我需要通过在 TaskItem 里另外创建一个组件，监听该组件的卸载事件，以进行卸载操作。
但 unmount 能用了并不代表事情结束了。在 DOM 里移除监听器需要传入添加监听器时的函数，而这个函数竟然是不能保证拿到相同的。
什么意思呢？这是我第一次发现 Vue 的 render 函数是每更新一次就调用一次的。此前我认为 render 函数是只会触发一次，收集依赖，后续直接在里面的 VNode 更新。好家伙，用了这么久的 Vue，这竟然是第一天才知道这一点。
那我把函数装进 ref 里总该行了吧？实测是不行的。mount 时拿到的装进 ref 里的函数，跟 unmount 里拿到的不是同一个，而这是连使用 watch 都监听不到的引用变化。
至于把函数丢进组件外面这个方法，其实也不可行。因为要在函数里使用一个组件内的 ref，这个没法丢出去。
目前实在是想不到什么好的解决方法了。网上说函数式组件不常用，它一般出现在比较简单的组件上。那后面考虑把 TaskItem 改用 class 组件实现一下再试试行不行吧。class 组件应该会有生命周期了。

## 2023-04-06

今日完成了 popup 的迁移，顺便微调了一下它的动画。

然后做了退出前检查。在这过程中也添加了一个小蓝表情包图片。然后把之前写的 ButtonRole 改成 ButtonType，这是为了把 role 留出来做 Msgbox 的键盘事件响应。不过现在它不能响应 Escape 键，还得查查原因。同时，由于 FC 组件的问题，现在应该也是做不了 unmount 事件的。

除此之外，在做的过程中尝试整理一下 trimExt 这个函数，但是发现了问题。这个函数在 common 里被 getFFmpegParaArray 调用到，而这个函数同时会在后端和前端使用。而又因 path 这个东西好像没法在编译时决定引入哪个，所以后面还得搞搞它，不然编译不起来。

## 2023-04-19

稍微做了一下整理操作。

比如说上面提到的 trimExt 之类的东西。我把实现改成了无论浏览器还是 node 都统一使用 path-browserify；同时为了简化引用，我把 trimExt 和一些 path 相关的功能独立到了 path.ts 文件中。这样一来，就不需要 upath 了。

另外，把 vcodecs、acodecs、formats 都移动到了 params 文件夹，并把共同的 types 独立成文件。formats 现在也转换成了 ts。

global.d.ts 和 types.ts 里去掉了一些未引用的东西。

最后想尝试一下改了这么一轮后现在的后端还能不能正常编译。结果是——vite 可以，webpack 不能。
webpack 把 renderer 的 ts 错误都找了出来。这就非常奇怪，因为我找了一轮，后端里并没有引用前端代码的地方，就连 webpack config 里也没涉及到 renderer 相关的东西，但它就是关心。
目前认为应该是 webpack 在处理前先把代码给了 ts，tsconfig 里配置了 include，然后就一股脑全编译了。
anyway，把那些错误修正好之后，webpack 就能编译了。

## 2023-08-14

很久没拿起来过 FFBox 的代码了，一上手其实并不太记得要做什么。

之前遗留下来的一个问题是 FFBox 后端不能正常使用，只能把旧版的 FFBox 启动起来给现在的前端调试。由于这里涉及到项目重构，所以出现这种问题有可能是由于重构时某些代码没改好所致的，不好定位，容易沮丧。如果说为什么前面的开发工作中断了那么长一段时间，这个也可算是其中一小点原因。
但其实调试起来并不困难，一下子就找到问题所在了。ws 这个库在更新之后，接收消息的 api 发生了变化，[这里](https://github.com/websockets/ws/issues/2108)便有人提出了这个问题。改一下就好了。

另外在做这个之前，我想随便放点任务进去跑一跑主流程，看看哪里出问题。我打开了控制台，看见了 InputBox 的 warning，便给它修了。另外也把 typeCheck 和 notNull 这些比较散的校验逻辑做成了更现代一些的 validator，另外还加上了 fixer，是一些「本想放到小版本，但既然都想到了自己也在用那就做了」的优化。

不过最重要的还是把后端搞能用了。所以等把前后端关联启动做好了，就可以直接自己先把这软件试用一段时间了。

## 2023-08-17

我是一个有强迫症的人——
比如说在分支管理上，我就喜欢整洁、一致的。
FFBox 刚开始做的时候，我还不会用 git，所以一整个版本下来其实才一个 commit。
工作之后，这个习惯肯定就不是这样了嘛。
那要怎么反映到 FFBox 上呢？
作为一个有强迫症的人，我可不接受东西做着做着突然就变了。得等到新版本开始，在 git graph 上用另一种颜色的线来呈现。
所以直到现在，在 FFBox 上还是使用着做两三天内容才发一次 commit 的习惯 /doge

上面是题外话了😂。只是在做的时候发现，有些东西我本该一年前就做了。咕到时代都变了还没发得出来一个版本，有感而发。
这句“有些东西”，就是指今天在做的由前端启动后端的机制。
公司的项目恰好也使用 electron 前端 + 某语言后端的机制去做（并不完全是“恰好”，不细说）。那众所周知，“工作只是用时间和生命换金钱，摸鱼才是赚到”，要是能在工作中学自己要用的东西，那也是赚到。在设计这套前后端模式的时候，我就把 FFmpegInvoke 里的一些函数抽了出来，做了个 processInstance 用于把 node ChildProcess 包装成一个更易操作的对象，同时附加输出解析功能。一年过去了，这东西终于可以引进 FFBox 了。不过这样就跟 FFmpegInvoke 有些功能重复，看后期有没有方法让 FFmpegInvoke 也用上它。目前的问题在于暂停进程功能需要用到 osBridge，这玩意就并不是在后端和前端主进程都有的东西。

然后就可以着手把启动后端的功能引进代码里。看了一下 3.0 的做法是由渲染进程通知主进程启动，现在也可大致这么做，方便当后端崩了（虽然一般不会崩）之后由前端主动点击重启。

## 2023-08-18

昨天做的时候就遇到一个问题：后端在打包后会放在哪里呢？想到这点之后我开始打包。结果——打包失败。
——挺搞心态的，就不能让我好好写个程序😇

第一个问题是：启动 exe 后主进程报错：`cannot find module 'conf'`。谷歌上似乎完全找不到这个问题。
回退一些版本之后出现了第二个问题：渲染进程报错：`Failed to resolve module specifier "vue". Relative references must start with either "/", "./", or "../".`。

第二个问题总结出来的原因大致是在 js module 里不带相对路径引用“vue”找不到，于是我试着把 node_modules 复制到生成出来的包的各个目录下，还是找不到。
关于这个问题，有人说是 pinia 的原因，但我实测不是。实际上，我把版本一路倒回去，发现“完成项目初始配置（目录结构、配置文件）并打通编译打包流程”这个 commit 其实并没有完全打通全流程，只到了编译出来一个白屏 exe 之后就停止了😓。
于是我今天开始找之前用第三方框架弄的项目。然后发现*草鞋没号*的 `electron-vue-vite` 打包出来同样不能用，只有 `electron-vite` 是能用的。
问题出在哪呢？我开始对比 vite config。但实际上我没去“对比”。因为我发现了配置项里的 external 把 package.json 里的 dependencies 全排除掉了。用不了 vue 有没有可能就是因为生成出来的包里没它呢？我试着把它注释掉，成了。版本往前几个之后又遇到了找不到 events 的错误。把那句 `...builtinModules` 注释掉也解决问题了。
笑死，原来以前从来没真正跑通过。

解决第二个问题之后我就继续去解决第一个问题了吗？笑死，并没有。
因为近期遇到了班尼特事件，各种电脑硬件损坏。我把自己电脑的外存移动到公司电脑上用，然后今天就出现错误了——后来 chkdsk 给它扫出了上万个错误，编译打包什么的跑不通，因为 node_modules 里的东西出了问题，pnpm 缓存也出现了问题。我只能说，幸好我自己写的代码没出事😇。
6，半夜不下班搞这个。

完成修复之后就继续去解决第一个问题了。解决方法跟第二个问题类似，反复切换以前的 commit，看下从哪开始有问题。
定位到开始有问题的 commit 是“nodeBridge 直接调用改 jsb 调用；任务项支持选择；acodecs 和 vcodecs 转 TypeScript；参数盒动画效果、各页面实现并支持参数存储”。罪魁祸首其实是 electron-store，其实直接在报错信息里就能看到了，只是有点困，一开始没去看。
解决方法也非常类似——把 vite config 里的 `...Object.keys(pkgJSON.dependencies || {})` 去掉就行了。
俩问题都是同一个原因

所以说，以前究竟是碰到了什么问题要在 vite config 里把依赖排除掉🙈给自己挖了个大坑。

## 2023-08-19

今天要解决的一个剩余需求就是渲染进程初始化后通知主进程启动后端。

首先的操作是修改了一下 electron builder 的配置，让它可以不把 .map 打包进产物里，然后对后端 exe 进行一个移动和重命名。这步没什么问题。

然而，当我回到前天的进度，在代码里接通前后端的时候，就遇到了一点小问题😓——（你说为啥写个软件能出这么多问题呢
因为我的设想是前后端进程分离运行，前端或后端崩溃不影响另一方。然而，当我设定启动参数为 `{ detached: true }` 后，会遇到启动时瞬间弹一个黑窗的问题。到 google 上搜了一下，这个问题竟然已经放了几年都没人修复。详见 [issue](https://github.com/nodejs/node/issues/21825)。那只好暂时先按保持原逻辑，让它以不分离的形式运行好了。

至此，我这几个月以来的第一个 commit 终于完成了。虽然实测编译出来的东西并不能正常进行转码，还老是崩，但不重要了，这个 commit 主要负责把编译启动流程打通就够了。
